#!/usr/bin/env python3
"""
Git Integration Script
This script manages Git workflow integration with the sniffing system
"""

import os
import sys
import logging
import asyncio
import json
import subprocess
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from .config import SNIFFING_CONFIG, GIT_HOOKS
from .sniffing import SniffingSystem
from .mcp import MasterControlProgram

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('logs/git_integration.log'),
        logging.StreamHandler(sys.stdout)
    ]
)

logger = logging.getLogger(__name__)

class GitIntegration:
    """Manages Git workflow integration"""

    def __init__(self):
        self.mcp = MasterControlProgram()
        self.sniffing_system = SniffingSystem()
        self.report_dir = Path("reports/git")
        self.report_dir.mkdir(parents=True, exist_ok=True)
        self.git_dir = Path(".git")
        self.hooks_dir = self.git_dir / "hooks"

    async def initialize(self):
        """Initialize Git integration"""
        await self.mcp.initialize()
        await self._setup_git_hooks()

    async def _setup_git_hooks(self):
        """Set up Git hooks"""
        try:
            if not self.git_dir.exists():
                logger.error("Not a Git repository")
                return

            self.hooks_dir.mkdir(exist_ok=True)

            # Set up pre-commit hook
            if GIT_HOOKS.get("pre-commit"):
                await self._create_hook("pre-commit", self._generate_pre_commit_hook())

            # Set up pre-push hook
            if GIT_HOOKS.get("pre-push"):
                await self._create_hook("pre-push", self._generate_pre_push_hook())

            # Set up post-merge hook
            if GIT_HOOKS.get("post-merge"):
                await self._create_hook("post-merge", self._generate_post_merge_hook())

        except Exception as e:
            logger.error(f"Error setting up Git hooks: {e}")
            raise

    async def _create_hook(self, hook_name: str, content: str):
        """Create a Git hook"""
        try:
            hook_path = self.hooks_dir / hook_name
            hook_path.write_text(content)
            hook_path.chmod(0o755)
            logger.info(f"Created {hook_name} hook")

        except Exception as e:
            logger.error(f"Error creating {hook_name} hook: {e}")
            raise

    def _generate_pre_commit_hook(self) -> str:
        """Generate pre-commit hook content"""
        return """#!/bin/sh
# Pre-commit hook generated by MCP

echo "Running pre-commit checks..."

# Get staged files
staged_files=$(git diff --cached --name-only --diff-filter=ACM)

if [ -z "$staged_files" ]; then
    echo "No files to check"
    exit 0
fi

# Run sniffing on staged files
python -m scripts.advanced_analysis.manage_sniffing --files "$staged_files" --domains security code_quality unit

exit_code=$?

if [ $exit_code -ne 0 ]; then
    echo "Pre-commit checks failed. Please fix the issues before committing."
    exit 1
fi

echo "Pre-commit checks passed."
exit 0
"""

    def _generate_pre_push_hook(self) -> str:
        """Generate pre-push hook content"""
        return """#!/bin/sh
# Pre-push hook generated by MCP

echo "Running pre-push checks..."

# Get commits being pushed
while read local_ref local_sha remote_ref remote_sha
do
    # Get changed files
    changed_files=$(git diff --name-only $remote_sha..$local_sha)

    if [ -z "$changed_files" ]; then
        continue
    fi

    # Run comprehensive sniffing
    python -m scripts.advanced_analysis.manage_sniffing --files "$changed_files" --domains security functional browser api

    exit_code=$?

    if [ $exit_code -ne 0 ]; then
        echo "Pre-push checks failed. Please fix the issues before pushing."
        exit 1
    fi
done

echo "Pre-push checks passed."
exit 0
"""

    def _generate_post_merge_hook(self) -> str:
        """Generate post-merge hook content"""
        return """#!/bin/sh
# Post-merge hook generated by MCP

echo "Running post-merge checks..."

# Get changed files
changed_files=$(git diff-tree -r --name-only --no-commit-id ORIG_HEAD HEAD)

if [ -z "$changed_files" ]; then
    echo "No files to check"
    exit 0
fi

# Run security and dependency checks
python -m scripts.advanced_analysis.manage_sniffing --files "$changed_files" --domains security performance

exit_code=$?

if [ $exit_code -ne 0 ]; then
    echo "Warning: Post-merge checks found issues that should be addressed."
fi

exit 0
"""

    async def run_pre_commit_check(self, files: Optional[List[str]] = None) -> Dict:
        """Run pre-commit checks"""
        logger.info("Running pre-commit checks")

        try:
            # Get staged files if not specified
            if not files:
                result = subprocess.run(
                    ["git", "diff", "--cached", "--name-only", "--diff-filter=ACM"],
                    capture_output=True,
                    text=True
                )
                files = result.stdout.strip().split('\n')

            if not files or (len(files) == 1 and not files[0]):
                return {"status": "skip", "message": "No files to check"}

            # Run sniffing on specified domains
            results = await self.mcp.run_sniffing(
                files,
                domains=GIT_HOOKS["pre-commit"]
            )

            # Generate report
            report = await self._generate_hook_report("pre-commit", files, results)

            # Check if should block commit
            should_block = any(
                issue["severity"] in ["critical", "high"]
                for result in results.values()
                for issue in result["issues"]
            )

            return {
                "status": "fail" if should_block else "pass",
                "results": results,
                "report": report
            }

        except Exception as e:
            logger.error(f"Error in pre-commit check: {e}")
            return {"status": "error", "error": str(e)}

    async def run_pre_push_check(self, local_sha: str, remote_sha: str) -> Dict:
        """Run pre-push checks"""
        logger.info("Running pre-push checks")

        try:
            # Get changed files
            result = subprocess.run(
                ["git", "diff", "--name-only", f"{remote_sha}..{local_sha}"],
                capture_output=True,
                text=True
            )
            files = result.stdout.strip().split('\n')

            if not files or (len(files) == 1 and not files[0]):
                return {"status": "skip", "message": "No files to check"}

            # Run comprehensive sniffing
            results = await self.mcp.run_sniffing(
                files,
                domains=GIT_HOOKS["pre-push"]
            )

            # Generate report
            report = await self._generate_hook_report("pre-push", files, results)

            # Check if should block push
            should_block = any(
                issue["severity"] == "critical"
                for result in results.values()
                for issue in result["issues"]
            )

            return {
                "status": "fail" if should_block else "pass",
                "results": results,
                "report": report
            }

        except Exception as e:
            logger.error(f"Error in pre-push check: {e}")
            return {"status": "error", "error": str(e)}

    async def run_post_merge_check(self) -> Dict:
        """Run post-merge checks"""
        logger.info("Running post-merge checks")

        try:
            # Get changed files
            result = subprocess.run(
                ["git", "diff-tree", "-r", "--name-only", "--no-commit-id", "ORIG_HEAD", "HEAD"],
                capture_output=True,
                text=True
            )
            files = result.stdout.strip().split('\n')

            if not files or (len(files) == 1 and not files[0]):
                return {"status": "skip", "message": "No files to check"}

            # Run security and dependency checks
            results = await self.mcp.run_sniffing(
                files,
                domains=GIT_HOOKS["post-merge"]
            )

            # Generate report
            report = await self._generate_hook_report("post-merge", files, results)

            return {
                "status": "complete",
                "results": results,
                "report": report
            }

        except Exception as e:
            logger.error(f"Error in post-merge check: {e}")
            return {"status": "error", "error": str(e)}

    async def _generate_hook_report(self, hook_name: str, files: List[str],
                                  results: Dict) -> Dict:
        """Generate report for hook execution"""
        try:
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            report_file = self.report_dir / f"{hook_name}_report_{timestamp}.json"

            report = {
                "timestamp": datetime.now().isoformat(),
                "hook": hook_name,
                "files_checked": files,
                "summary": {
                    "total_files": len(files),
                    "files_with_issues": sum(1 for r in results.values() if r["issues"]),
                    "total_issues": sum(len(r["issues"]) for r in results.values()),
                    "issues_by_severity": {
                        "critical": sum(1 for r in results.values()
                                     for i in r["issues"] if i["severity"] == "critical"),
                        "high": sum(1 for r in results.values()
                                  for i in r["issues"] if i["severity"] == "high"),
                        "medium": sum(1 for r in results.values()
                                    for i in r["issues"] if i["severity"] == "medium"),
                        "low": sum(1 for r in results.values()
                                 for i in r["issues"] if i["severity"] == "low")
                    }
                },
                "results": results
            }

            with open(report_file, 'w') as f:
                json.dump(report, f, indent=2)

            return report

        except Exception as e:
            logger.error(f"Error generating hook report: {e}")
            raise

async def main():
    """Main function"""
    try:
        integration = GitIntegration()
        await integration.initialize()
        logger.info("Git integration initialized successfully")
    except Exception as e:
        logger.error(f"Git integration failed: {e}")
        sys.exit(1)

if __name__ == "__main__":
    asyncio.run(main())
